package codegen

import cats.data.State
import cats.effect.IO
import codegen.CodeGenerator.transformToState
import codegen.CodegenHelpers.getMain
import codegen.TypeSystemBootstrapper.initializeTypeSystemBuilder
import codegen.creator.impl._
import config.SETTINGS
import config.SETTINGS.NativeOperators
import javassist.{ClassPool, CtMethod}
import model._

final case class CodeGenerator(tks: List[Token[_]]) {

  def generateCode: IO[Unit] =
    for {
      _           <- logTokens
      codegenPlan <- buildCodegenPlan
      _           <- generate(codegenPlan)
    } yield ()

  def generate(codegenPlan: State[Context, String]): IO[Unit] =
    IO(codegenPlan.run(initContext).value._1)

  private def buildCodegenPlan: IO[State[Context, String]] =
    IO(
      tks
        .map(stateTransformer(getMain, "Main", "main"))
        .foldLeft(initializeTypeSystemBuilder)(
          (ss, aa) => ss.flatMap(_ => aa)
        )
        .flatMap(_ => finalizerState)
    )

  def stateTransformer(
      mthd:    CtMethod,
      execCls: String,
      execMtd: String
  ): Token[_] => State[Context, String] =
    (tkn: Token[_]) => transformToState(tkn, execCls, execMtd)

  private def finalizerState: State[Context, String] =
    State[Context, String] { ctx =>
      ctx.classnamesToWrite.foreach(
        c => ClassPool.getDefault.get(c).writeFile(SETTINGS.CompileOutputDir)
      )
      (ctx, s"written all generated bytecode to files in directory: ${SETTINGS.CompileOutputDir}")
    }

  private def logTokens = IO(println(tks))

  private def initContext: Context = Context(Map(), List())
}

object CodeGenerator {
  def transformToState(tkn: Token[_], execCls: String, execMtd: String): State[Context, String] =
    State[Context, String] { context =>
      tkn match {
        case DEF(elem, expr) => DefineCreator(context, elem.scalaVal, expr).handle
        case READDEF(elem: ID) =>
          new ReadCreator(context, elem.scalaVal).handle
        case WRITE(expr)        => WriteCreator(context, expr).handle
        case LAMBDA(vars, expr) => LambdaCreator(context, vars, expr).handle
        case LIST((lambda @ LAMBDA(_, _)) :: tail) =>
          generateLambdaApp(execCls, execMtd, context, lambda, tail)
        case LIST(ID(varName) :: tail) =>
          generateDefinedFunApp(execCls, execMtd, context, varName, tail)
        case IF(cond: Token[_], positive: Token[_], negative: Token[_]) =>
          generateDefinedFunApp(
            execCls,
            execMtd,
            context,
            "if",
            cond :: positive :: negative :: Nil
          )
      }
    }

  def generateLambdaApp(
      mtd:     CtMethod,
      context: Context,
      lambda:  LAMBDA,
      tail:    List[Token[_]]
  ): (Context, String) =
    generateLambdaApp(mtd.getDeclaringClass.getName, mtd.getName, context, lambda, tail)

  def generateLambdaApp(
      execCls: String,
      execMtd: String,
      context: Context,
      lambda:  LAMBDA,
      tail:    List[Token[_]]
  ): (Context, String) = {
    val (nctx, anonClassName) = transformToState(lambda, execCls, execMtd).run(context).value
    AppCreator(nctx, tail, anonClassName, execCls, execMtd).handleLambdaApp()
  }

  def generateDefinedFunApp(
      mtd:     CtMethod,
      ctx:     Context,
      varName: String,
      tail:    List[Token[_]]
  ): (Context, String) = {
    if (isNativeOperator(varName))
      NativeAppCreator(mtd.getDeclaringClass.getName, mtd.getName, ctx, varName, tail).handle
    else if (isRecursiveOperator(varName, ctx))
      RecursiveAppCreator(mtd.getDeclaringClass.getName, mtd.getName, ctx, varName, tail).handle
    else
      AppCreator(
        ctx,
        tail,
        ctx.scope(varName).anonClassName,
        mtd.getDeclaringClass.getName,
        mtd.getName
      ).handleLambdaApp()
  }

  def isRecursiveOperator(varName: String, ctx: Context) =
    ctx.scope.keySet contains varName

  def generateDefinedFunApp(
      execCls: String,
      execMtd: String,
      ctx:     Context,
      varName: String,
      tail:    List[Token[_]]
  ): (Context, String) = {
    if (isNativeOperator(varName)) NativeAppCreator(execCls, execMtd, ctx, varName, tail).handle
    else if (isRecursiveOperator(varName, ctx))
      RecursiveAppCreator(execCls, execMtd, ctx, varName, tail).handle
    else
      AppCreator(ctx, tail, ctx.scope(varName).anonClassName, execCls, execMtd).handleLambdaApp()
  }

  def isNativeOperator(varName: String) = NativeOperators.contains(varName)

}
